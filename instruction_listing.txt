Instruction listing

|-----------|-------------------|-----|-----|-----|
| MNEMONIC  | B0                | B1  | B2  | B*  |
|-----------|-------------------|-----|-----|-----|
| output    | 0 0 0 0   aaaa    |     |     |     | Output register A
| loadimm   | 0 0 0 1   aaaa    | V V | * * |     | load immediate value V into register A
| loadmem   | 0 0 1 0   aaaa    | M M | M M | M M | Load value at memory address M into register A
| storemem  | 0 0 1 1   aaaa    | M M | M M | M M | Store value of register A at memory address M
| loadreg   | 0 1 0 0   aaaa    | B - |     |     | Load value stored at global address in register B into register A
| storereg  | 0 1 0 1   aaaa    | B - |     |     | Store value in register A at global address in register B
| jmp       | 0 1 1 0   ----    | L L |     |     | Unconditional branch to local address L relative to start of current function
| jo        | 0 1 1 1   aaaa    | L L |     |     | Conditional branch to local address L relative to start of current function if register A is odd
| call      | 1 0 0 0   ----    | F F | F F |     | Call function defined at address F << 8
| callreg   | 1 0 0 1   aaaa    |     |     |     | Indirect call of function address in register A << 8
| return    | 1 0 1 0   ----    |     |     |     | Return
| swap      | 1 0 1 1   aaaa    | B - |     |     | swap values in registers A and B
| [OP]      | 1 1 0 s   ssss    | A B |     |     | Perform binary operation S (see below) on registers A and B, storing the result in A
| [OP]imm   | 1 1 1 s   ssss    | A - | V V | * * | Perform binary operation S (see below) on register A and immediate value V, storing the result in A
|-----------|-------------------|-----|-----|-----|

Binary register operations
    Read values of registers A and B, compute result, store result in register A

|----------|-----------|-------------------------------|
| MNEMONIC | CODE      | EXPLANATION                   |
|----------|-----------|-------------------------------|
| copy     | 0 0 0 0 0 | B                             | TODO: no longer needed now that loadimm and swap exist
| not      | 0 0 0 0 1 | ~B                            |
| neg      | 0 0 0 1 0 | MAX - B                       | TODO: isn't this the same as "not"?
| reverse  | 0 0 0 1 1 | reverse(B)                    |
| numones  | 0 0 1 0 0 | byteswap(B)                   |
| numzeros | 0 0 1 0 1 | popcount(B)                   |
| and      | 0 0 1 1 0 | A & B                         |
| or       | 0 0 1 1 1 | A | B                         |
| xor      | 0 1 0 0 0 | A ^ B                         |
| shl      | 0 1 0 0 1 | A << B                        |
| shlm     | 0 1 0 1 0 | A << (B % BITS)               |
| shr      | 0 1 0 1 1 | A >> B                        |
| shrm     | 0 1 1 0 0 | A >> (B % BITS)               |
| rotl     | 0 1 1 0 1 | rotl(A, B)                    |
| rotr     | 0 1 1 1 0 | rotr(A, B)                    |
| addc     | 0 1 1 1 1 | min(A + B, MAX)               |
| addm     | 1 0 0 0 0 | (A + B) & MAX                 |
| subc     | 1 0 0 0 1 | max(A - B, 0)                 |
| subm     | 1 0 0 1 0 | (A - B) & MAX                 |
| absdiff  | 1 0 0 1 1 | abs(B - A)                    |
| mulc     | 1 0 1 0 0 | min(A * B, MAX)               |
| mulm     | 1 0 1 0 1 | (A * B) & MAX                 |
| div      | 1 0 1 1 0 | A / max(B, 1)                 |
| mod      | 1 0 1 1 1 | A % max(B, 1)                 |
| powm     | 1 1 0 0 0 | pow(A, B) & MAX               |
| powc     | 1 1 0 0 1 | min(pow(A, B), MAX)           |
| gt       | 1 1 0 1 0 | A > B                         |
| ge       | 1 1 0 1 1 | A >= B                        |
| lt       | 1 1 1 0 0 | A < B                         |
| le       | 1 1 1 0 1 | A <= B                        |
| eq       | 1 1 1 1 0 | A == B                        |
| ne       | 1 1 1 1 1 | A != B                        |
|----------|-----------|-------------------------------|
